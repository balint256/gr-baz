/* -*- c++ -*- */
/*
 * Copyright 2004 Free Software Foundation, Inc.
 *
 * This file is part of GNU Radio
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * gr-baz by Balint Seeber (http://spench.net/contact)
 * Information, documentation & samples: http://wiki.spench.net/wiki/gr-baz
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <baz_gate.h>
#include <gnuradio/io_signature.h>
#include <pmt/pmt.h>

#include <stdio.h>
//#include <typeinfo>

/*
 * Create a new instance of baz_gate and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
baz_gate_sptr
baz_make_gate (int item_size, bool block /*= true*/, float threshold /*= 0.0*/, int trigger_length /*= 0*/, bool tag /*= false*/, double delay /*= 0.0*/, int sample_rate /*= 0*/, bool no_delay /*= false*/)
{
  return baz_gate_sptr (new baz_gate (item_size, block, threshold, trigger_length, tag, delay, sample_rate, no_delay));
}

/*
 * The private constructor
 */
baz_gate::baz_gate (int item_size, bool block, float threshold, int trigger_length, bool tag, double delay, int sample_rate, bool no_delay)
  : gr::block ("gate",
		   gr::io_signature::make33 (2, 3, item_size, sizeof(/*char*/float), item_size),
		   gr::io_signature::make (1, 1, item_size))
  , d_item_size(item_size), d_threshold(threshold), d_trigger_length(trigger_length), d_block(block), d_tag(tag), d_delay(delay), d_sample_rate(sample_rate), d_no_delay(no_delay)
  , d_trigger_count(0), d_time_offset(-1), d_in_burst(false), d_output_index(0)
{
  memset(&d_last_time, 0x00, sizeof(uhd::time_spec_t));

  fprintf(stderr, "[%s<%i>] Threshold: %.1f, length: %d, item size: %d, blocking: %s, tag: %s, delay: %.6f, sample rate: %d, no delay: %s\n", name().c_str(), unique_id(), threshold, trigger_length, item_size, (block ? "yes" : "no"), (tag ? "yes" : "no"), delay, sample_rate, (no_delay ? "yes" : "no"));
}

/*
 * Our virtual destructor.
 */
baz_gate::~baz_gate ()
{
}

void baz_gate::forecast(int noutput_items, gr_vector_int &ninput_items_required)
{
  for (int i = 0; i < ninput_items_required.size(); ++i)
    ninput_items_required[i] = noutput_items;
  //ninput_items_required[0] = (d_block ? 0 : noutput_items);
  //ninput_items_required[1] = noutput_items;
}

void baz_gate::set_blocking(bool enable)
{
  fprintf(stderr, "[%s<%i>] Blocking: %s\n", name().c_str(), unique_id(), (enable ? "yes" : "no"));
  gr::thread::scoped_lock guard(d_mutex);
  d_block = enable;
}

void baz_gate::set_threshold(float threshold)
{
  fprintf(stderr, "[%s<%i>] Threshold: %.1f\n", name().c_str(), unique_id(), threshold);
  d_threshold = threshold;
}

void baz_gate::set_trigger_length(int trigger_length)
{
  fprintf(stderr, "[%s<%i>] Length: %d\n", name().c_str(), unique_id(), trigger_length);
  d_trigger_length = trigger_length;
}

void baz_gate::set_tagging(bool enable)
{
  fprintf(stderr, "[%s<%i>] Tag: %s\n", name().c_str(), unique_id(), (enable ? "yes" : "no"));
  d_tag = enable;
}

void baz_gate::set_delay(double delay)
{
  fprintf(stderr, "[%s<%i>] Delay: %.6f\n", name().c_str(), unique_id(), delay);
  d_delay = delay;
}

void baz_gate::set_sample_rate(int sample_rate)
{
  fprintf(stderr, "[%s<%i>] Sample rate: %d\n", name().c_str(), unique_id(), sample_rate);
  d_sample_rate = sample_rate;
}

void baz_gate::set_no_delay(bool no_delay)
{
  fprintf(stderr, "[%s<%i>] Delay: %.6f\n", name().c_str(), unique_id(), (no_delay ? "yes" : "no"));
  d_no_delay = no_delay;
}

static const pmt::pmt_t SOB_KEY = pmt::string_to_symbol("tx_sob");
static const pmt::pmt_t EOB_KEY = pmt::string_to_symbol("tx_eob");
static const pmt::pmt_t TX_TIME_KEY = pmt::string_to_symbol("tx_time");
static const pmt::pmt_t RX_TIME_KEY = pmt::string_to_symbol("rx_time");

static bool _first = true;
static gr_complex _first_c = gr_complex(-1,-1);

int
baz_gate::general_work (int noutput_items, gr_vector_int &ninput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
  gr::thread::scoped_lock guard(d_mutex);
  
  const char *in = (char*)input_items[0];
  const float *level = (float*)input_items[1];
  char *out = (char*)output_items[0];
/*
for (int k = 0; k < min(10,ninput_items[0]); ++k) {
    gr_complex* c = (gr_complex*)(in + d_item_size * k);
    fprintf(stderr, "\t-> %.5f,%.5f\n", )
}*/

  int tag_channel = ((ninput_items.size() >= 3) ? 2 : 1);
  const uint64_t nread = nitems_read(tag_channel); //number of items read on port 0
  std::vector<gr::tag_t> tags;

  int tag_index_offset = 0;
  uint64_t next_tag_offset = -1;
  get_tags_in_range(tags, tag_channel, nread, nread+ninput_items[tag_channel], RX_TIME_KEY);
  for (int i = 0; i < tags.size(); ++i) {
//    fprintf(stderr, "[%s] Tag #%d %s\n", name().c_str(), i, pmt::write_string(tags[i].key).c_str());
  }
  if (tags.size() > 0) {
    next_tag_offset = tags[0].offset;
//    fprintf(stderr, "[%s] Tags: %d (next offset: %d)\n", name().c_str(), tags.size(), next_tag_offset);
  }

//fprintf(stderr, "[%s] Work %d, %d, %d\n", name().c_str(), noutput_items, ninput_items[0], ninput_items[1]);

  int noutput = 0, j = 0;
  for (int i = 0; i < noutput_items; i++) {

    if (next_tag_offset == (nitems_read(tag_channel) + i)) {
      gr::tag_t tag = tags[tag_index_offset++];

      uint64_t _next = -1;
      if (tag_index_offset < tags.size())
        _next = tags[tag_index_offset].offset;

      d_time_offset = 0;
      d_last_time = uhd::time_spec_t(
          pmt::to_uint64(pmt::tuple_ref(tag.value, 0)),
          pmt::to_double(pmt::tuple_ref(tag.value, 1)));
//      fprintf(stderr, "[%s] Processing tag #%d %s (next offset: %d) time: %f\n", name().c_str(), next_tag_offset, pmt::write_string(tag.key).c_str(), _next, d_last_time.get_real_secs());

      next_tag_offset = _next;
    }
    else
      ++d_time_offset;

//    gr_complex* c = (gr_complex*)(in + (i * d_item_size));
//fprintf(stderr, "[%s] Sample %.1f, %.1f\n, level %.1f", name().c_str(), c->real(), c->imag(), level[i]);
    if ((level[i] >= d_threshold) || (d_trigger_count > 0)) {
        bool was_in_burst = d_in_burst;
/*
      tags.clear();
      get_tags_in_range(tags, 0, nread+i, nread+i+1);
      if (tags.size() > 0)
        fprintf(stderr, "[%s] Tag offset %d\n", name().c_str(), tags[0].offset);
*/
      if (d_trigger_count > 0)
        --d_trigger_count;

      if ((d_trigger_count == 0) && (level[i] >= d_threshold)) { // 'else' to avoid double trigger and offset in incoming repeating vector
        fprintf(stderr, "[%s<%i>] Triggered: %.1f, current count: %d\n", name().c_str(), unique_id(), level[i], d_trigger_count);
        d_trigger_count = (d_trigger_length - 1);
/*
        uhd::tx_metadata_t md;
        md.start_of_burst = true;
        md.end_of_burst = false;
        md.has_time_spec = true;
        md.time_spec = uhd::time_spec_t(seconds_in_future);
        add_item_tag(0, offset, key, value);
*/
        if (d_tag && (d_in_burst == false)) {
          //assert(d_in_burst == false);  // FIXME: This can fail if changing d_tag at runtime

          add_item_tag(0, nitems_written(0)+j, SOB_KEY, pmt::pmt_from_bool(true));
          if (d_no_delay == false) {
            uhd::time_spec_t next = (d_last_time + uhd::time_spec_t(0, d_time_offset, d_sample_rate)) + uhd::time_spec_t(d_delay);
            add_item_tag(0, nitems_written(0)+j, TX_TIME_KEY, pmt::pmt_make_tuple(pmt::pmt_from_uint64(next.get_full_secs()), pmt::pmt_from_double(next.get_frac_secs())));
          }

          d_in_burst = true;
        }
      }
      else if (d_trigger_count == 0) {
/*
        uhd::tx_metadata_t md;
        md.start_of_burst = false;
        md.end_of_burst = true;
        md.has_time_spec = false;
        add_item_tag(0, offset, key, value);
*/
        if (d_in_burst) {
          fprintf(stderr, "[%s<%i>] EOB %d + %d\n", name().c_str(), unique_id(), nitems_written(0), j);
          add_item_tag(0, nitems_written(0)+j, EOB_KEY, pmt::pmt_from_bool(true));
          d_in_burst = false;
        }
      }
if (d_in_burst == false) {
    gr_complex* c = (gr_complex*)(in + ((noutput-1) * d_item_size));
    //fprintf(stderr, ">>> #%05d %.1f,%.1f (%d)\n", noutput, c->real(), c->imag(), d_trigger_count);
}
      memcpy(out + (j * d_item_size), in + (noutput * d_item_size), d_item_size);

        j++;
      ++noutput;

      if ((d_in_burst || was_in_burst) && _first) {
          gr_complex* c = (gr_complex*)(in + ((noutput-1) * d_item_size));
          //if (*c != _first_c) {
//            fprintf(stderr, "#%05d %.5f,%.5f (trig: %d, i: %d)\n", noutput, c->real(), c->imag(), d_trigger_count, i);
          //  _first_c = *c;
          //}
      }
      else if (d_in_burst == false && _first) {
          gr_complex* c = (gr_complex*)(in + ((noutput-1) * d_item_size));
          fprintf(stderr, "!!! #%05d %.1f,%.1f (%d)\n", noutput, c->real(), c->imag(), d_trigger_count);
      }
      if ((d_in_burst == false) && was_in_burst && _first)
        _first = false;
    }
    else if (d_block == false) {
      memset(out + (j * d_item_size), 0x00, d_item_size);
      j++;
    }
  }

  assert((d_block) || (j == noutput_items));    // Triggers if changed during work (no thread safety)
  /*if (noutput_items != ninput_items[1]) { // This is not true
    fprintf(stderr, "[%s] noutput items: %d, gate control input items: %d\n", name().c_str(), noutput_items, ninput_items[1]);
  }*/

  consume(0, noutput);
  consume(1, noutput_items);
  if (ninput_items.size() >= 3)
    consume(2, noutput_items);

  return j;
}
